# 티켓팅 백엔드 로직 + Redis + 실시간 SSE 흐름

## 오늘 스터디 목적

* Redis와 Spring Boot를 연결
* 좌석 데이터를 Redis에 초기화하고 상태를 변경
* SSE(Server-Sent Events) 기반 실시간 반영

---

# 0단계. Docker로 Redis 띄우기

```bash
docker run -d \
  --name redis-local \
  -p 6379:6379 \
  redis
```

* 이후 `docker exec -it redis-local redis-cli` 로 접속 확인

---

# 1단계. Spring Boot + Redis 연결

### Maven 의존성 추가

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

### application.yml 설정

```yaml
spring:
  redis:
    host: localhost
    port: 6379
```

### Redis 연결 테스트 코드

```java
@RestController
public class RedisTestController {
    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @GetMapping("/redis-test")
    public String test() {
        redisTemplate.opsForValue().set("hello", "world");
        return redisTemplate.opsForValue().get("hello");
    }
}
```

---

# 2단계. 좌석 코드 생성 및 Redis 초기화

* 구역 3종류(F01, S01, R01) × 각 100석 = 총 300석
* Redis 키 형식: `seat:{showId}:{seatCode}` → 값: `available`

```java
public class SeatCodeGenerator {
    public static List<String> generateSeatCodes(String zone) {
        List<String> seatCodes = new ArrayList<>();
        char[] rows = "ABCDEFGHIJ".toCharArray();
        for (char row : rows) {
            for (int num = 1; num <= 10; num++) {
                seatCodes.add(String.format("%s-%c-%02d", zone, row, num));
            }
        }
        return seatCodes;
    }
}
```

```java
public void initializeSeats(Long showId) {
    for (String zone : List.of("F01", "S01", "R01")) {
        for (String seatCode : SeatCodeGenerator.generateSeatCodes(zone)) {
            String key = String.format("seat:%d:%s", showId, seatCode);
            redisTemplate.opsForValue().set(key, "available");
        }
    }
}
```

---

# 3단계. 좌석 상태 조회 API

```java
public List<SeatInfo> getSeatInfoByZone(Long showId, String zone) {
    return SeatCodeGenerator.generateSeatCodes(zone).stream()
        .map(code -> {
            String key = "seat:" + showId + ":" + code;
            String status = redisTemplate.opsForValue().get(key);
            if (status == null) status = "unknown";
            return new SeatInfo(code, code.split("-")[1], Integer.parseInt(code.split("-")[2]), status);
        }).toList();
}
```

---

# 4단계. 좌석 선점 (selected 상태로 변경 + TTL)

```java
public boolean trySelectSeat(Long showId, String seatCode, String userId) {
    String key = "seat:" + showId + ":" + seatCode;
    String value = "selected:" + userId;
    return redisTemplate.opsForValue().setIfAbsent(key, value, Duration.ofSeconds(10));
}
```

---

# 5단계. TTL 만료 테스트

```bash
GET seat:1001:F01-A-01
TTL seat:1001:F01-A-01
# 10초 뒤 GET → (nil)
```

---

# 6단계. 예약 확정 로직 (reserved + TTL 제거)

```java
@Transactional
public void confirmReservation(Long showId, String seatCode, String userId) {
    String key = "seat:" + showId + ":" + seatCode;
    String status = redisTemplate.opsForValue().get(key);
    if (!status.equals("selected:" + userId)) throw ...;

    reservationRepository.save(...);
    redisTemplate.opsForValue().set(key, "reserved:" + userId);
    redisTemplate.persist(key); // TTL 제거
}
```

---

# 7단계. 실시간 좌석 상태 반영 (SSE 기반)

## 기술 선택 이유

* 구현 난이도 낮고 단방향 알림 구조에 적합
* 2시간 실습에 적절한 구현 효율성
* WebSocket및 kafka 메세지 큐 방식은 실제 서비스 시 고려 예정

---

## SSE 흐름 요약

1. 클라이언트 → `/subscribe/{showId}/{zone}`로 구독 요청
2. 좌석 선점 또는 예약 발생 시 서버에서 해당 구역에 이벤트 전파
3. 클라이언트에서 콘솔로 실시간 수신 확인

---

## SeatUpdateResponse DTO

```java
@Getter
@AllArgsConstructor
public class SeatUpdateResponse {
    private String seatCode;
    private String status;
}
```

---

## SeatSseService

```java
@Service
public class SeatSseService {
    private final Map<String, List<SseEmitter>> subscribers = new ConcurrentHashMap<>();

    public SseEmitter subscribe(Long showId, String zone) {
        String key = key(showId, zone);
        SseEmitter emitter = new SseEmitter(10 * 60 * 1000L);
        subscribers.computeIfAbsent(key, k -> new CopyOnWriteArrayList<>()).add(emitter);

        emitter.onCompletion(() -> subscribers.get(key).remove(emitter));
        emitter.onTimeout(() -> subscribers.get(key).remove(emitter));

        return emitter;
    }

    public void notifySeatUpdate(Long showId, String zone, String seatCode, String status) {
        String key = key(showId, zone);
        List<SseEmitter> emitters = subscribers.getOrDefault(key, List.of());
        for (SseEmitter emitter : emitters) {
            try {
                emitter.send(SseEmitter.event()
                    .name("seat-update")
                    .data(new SeatUpdateResponse(seatCode, status)));
            } catch (IOException e) {
                emitter.completeWithError(e);
            }
        }
    }

    private String key(Long showId, String zone) {
        return showId + ":" + zone;
    }
}
```

---

## SeatSseController

```java
@RestController
@RequiredArgsConstructor
public class SeatSseController {

    private final SeatSseService seatSseService;

    @GetMapping(value = "/subscribe/{showId}/{zone}", produces = "text/event-stream")
    public SseEmitter subscribe(@PathVariable Long showId, @PathVariable String zone) {
        return seatSseService.subscribe(showId, zone);
    }
}
```

---

## 클라이언트 구독 예시 (브라우저 콘솔)

```html
<script>
const eventSource = new EventSource("/subscribe/1001/F01");

eventSource.addEventListener("seat-update", function(e) {
    const data = JSON.parse(e.data);
    console.log(`좌석 ${data.seatCode} → 상태 변경: ${data.status}`);
});
</script>
```

---

## 요약

* 구독(subscribe)과 전송(notify) 구조를 명확히 분리
* 구역별 키 기준으로 채널 분리 설계
* 예약 확정 시 TTL 제거로 안정성 확보
* 실시간 반영은 단방향 알림이면 SSE로 충분 -> webSocket, kafka등은 추후 실제 서비스에서 고려

---

## 실습 계획 정리

* 오늘: Redis 연결 → 좌석 상태 → SSE 구조 스터디
* 내일: 선점/예약 로직에서 실제로 notifySeatUpdate 호출 → 실시간 반영 확인
