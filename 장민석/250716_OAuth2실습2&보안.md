## 카카오 OAuth2 연동 (Spring Boot)

---

### application.properties (주요 부분)

```properties
spring.security.oauth2.client.registration.kakao.client-id=${KAKAO_CLIENT_ID}
spring.security.oauth2.client.registration.kakao.client-secret=${KAKAO_CLIENT_SECRET}
spring.security.oauth2.client.registration.kakao.redirect-uri={baseUrl}/login/oauth2/code/kakao
spring.security.oauth2.client.registration.kakao.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.kakao.scope=profile_nickname,profile_image,account_email
spring.security.oauth2.client.registration.kakao.client-authentication-method=client_secret_post

spring.security.oauth2.client.provider.kakao.authorization-uri=https://kauth.kakao.com/oauth/authorize
spring.security.oauth2.client.provider.kakao.token-uri=https://kauth.kakao.com/oauth/token
spring.security.oauth2.client.provider.kakao.user-info-uri=https://kapi.kakao.com/v2/user/me
spring.security.oauth2.client.provider.kakao.user-name-attribute=id
```

---

### .env 예시

```
KAKAO_CLIENT_ID=your-rest-api-key
KAKAO_CLIENT_SECRET=your-admin-key
```

---

### Application.java 주요 코드

```java
import io.github.cdimascio.dotenv.Dotenv;

@SpringBootApplication
public class YourApplication {
    public static void main(String[] args) {
        Dotenv dotenv = Dotenv.load();
        dotenv.entries().forEach(entry -> System.setProperty(entry.getKey(), entry.getValue()));
        SpringApplication.run(YourApplication.class, args);
    }
}
```

---

### UserController.java (주요 부분)

```java
@RestController
public class UserController {

    @GetMapping("/mypage")
    public UserDto mypage(@AuthenticationPrincipal OidcUser oidcUser) {
        if (oidcUser == null) {
            return null;
        }

        String email = null;
        String nickname = null;
        String picture = null;

        if (oidcUser.getAttributes().containsKey("kakao_account")) {
            var account = (Map<String, Object>) oidcUser.getAttributes().get("kakao_account");
            email = (String) account.get("email");

            if (account.containsKey("profile")) {
                var profile = (Map<String, Object>) account.get("profile");
                nickname = (String) profile.get("nickname");
                picture = (String) profile.get("profile_image_url");
            }
        } else {
            email = oidcUser.getEmail();
            nickname = oidcUser.getFullName();
            picture = oidcUser.getPicture();
        }

        return new UserDto(email, nickname, picture);
    }
}
```

---

### UserDto 예시

```java
public class UserDto {
    private String email;
    private String nickname;
    private String picture;

    public UserDto() {}

    public UserDto(String email, String nickname, String picture) {
        this.email = email;
        this.nickname = nickname;
        this.picture = picture;
    }

    // Getter/Setter
}
```

---

구글은 OIDC 표준 응답 구조를 그대로 사용하므로 위 코드에서 별다른 수정 없이도 동일하게 동작함
네이버 로그인은 구조가 구글, 카카오와 거의 유사하므로 실습은 생략함

---

## 보안: HttpOnly 처리 이유와 방법

---

### HttpOnly 쿠키를 쓰는 이유

- 세션ID나 액세스 토큰을 클라이언트 측 JavaScript가 읽지 못하도록 막아줌.
- XSS(스크립트 삽입 공격)으로 인한 탈취를 방지
- 브라우저가 서버로 자동 전송하도록 하여 사용자 인증 상태를 안전하게 유지

---

### 처리 방법

- 스프링 시큐리티 OAuth2 Client가 로그인 성공 시 HttpOnly 세션 쿠키를 자동으로 발급
- 클라이언트는 withCredentials 옵션으로 이 쿠키를 전송하여 인증 상태를 유지
- 서버는 세션에서 사용자 정보를 관리하고 필요할 때만 최소한의 정보(DTO)로 클라이언트에 응답

---

예시 Set-Cookie 헤더

```
Set-Cookie: JSESSIONID=abc123; HttpOnly; Secure; SameSite
```

---

** 설계의 핵심 **
쿠키에는 세션ID 같은 식별자만 저장, 개인정보는 서버 세션에서 관리해 필요할 때 안전하게 제공.

````

---

## 추가적으로 적용하면 좋은 OAuth2 보안 리서치


### HTTPS 적용

* 인증 코드, 토큰 교환, 세션 쿠키 전송 모두 HTTPS로 암호화
* 중간자 공격(MITM) 방지
* 배포 환경에서는 반드시 HTTPS 사용 권장

---

### Redirect URI 관리

* 인가 코드 탈취 방지를 위해 OAuth2 Redirect URI를 정확히 관리
* 카카오/구글 콘솔에 등록된 URI와 서버 설정을 일치
* 동적으로 생성하지 않고 고정된 값으로 유지

---

### Scope 최소화

* 사용자 권한 요청 시 꼭 필요한 정보만 포함
* profile\_nickname, profile\_image, account\_email도 사용 목적을 명확히 하고 최소 권한 요청

---

### CSRF 방어

* OAuth2 state 파라미터를 통해 CSRF 공격 방지
* 스프링 시큐리티 OAuth2 Client가 자동 관리하지만, 커스텀 구현 시 유의

---

### 세션 관리

* 세션 고정(Session Fixation) 공격 방지
* 스프링 시큐리티가 로그인 성공 시 세션 ID를 새로 생성하도록 설정 가능
* 세션 만료 시간 적절히 설정

---

### 토큰 저장 위치

* Access Token이나 Refresh Token을 클라이언트 측 로컬스토리지에 저장하지 않음
* 서버 측 HttpOnly 쿠키나 세션 스토리지 사용

---

### 로그아웃 처리

* 클라이언트 로그아웃 시 서버 세션 무효화
* OAuth2 공급자에서의 로그아웃 연동 여부 고려

---

### 예시 코드 - 세션 무효화

```java
.logout(logout -> logout
    .logoutUrl("/logout")
    .logoutSuccessUrl("/")
    .invalidateHttpSession(true)
    .deleteCookies("JSESSIONID")
)
````

---

- 쿠키에는 세션ID 같은 최소한의 식별자만 저장
- 민감한 사용자 정보는 서버 세션에서 안전하게 관리하며 필요할 때만 클라이언트로 제공
- HTTPS와 CSRF 방어, 세션 관리 설정 등을 통해 추가적인 보안성을 확보

---
