

# 모놀리식 아키텍처

- 모든 비즈니스 기능이 하나의 통합된 코드 베이스와 데이터베이스로 구성된 전통적인 소프트웨어 개발 방식
- 하나의 큰 애플리케이션에 다양한 서비스와 로직이 함께 포함되어 동작

### 장단점

1. 장점

- 간편한 개발 및 배포 프로세스
- 디버깅과 테스트가 비교적 쉬움
- 작은 프로젝트나 초기 단계에서는 높은 생산성

2. 단점

- 시스템이 커질수록 복잡도가 증가하고 유지보수가 어려워짐
- 일부 기능만 변경해도 전체 시스템을 다시 배포해야 함
- 확장성, 고가용성 요구사항에 한계가 있음

# 마이크로서비스 아키텍처


- 애플리케이션을 여러 개의 작은, 독립적인 서비스로 분리하여 개발 및 배포하는 현대적 아키텍처
- 각 서비스는 독립적으로 동작하며 자체 데이터베이스와 로직을 가질 수 있음
- 각 서비스가 별도의 배포 단위로 관리됨
- 서비스 간 통신은 주로 API를 통해 이루어짐

### 장단점

1. 장점

- 필요에 따라 **서비스별로 확장** 및 배포 가능
- 장애 발생 시 전체가 아닌 일부 서비스만 영향받음
- 팀별로 독립적인 개발, 관리가 가능해 **대규모 조직에 적합**

2. 단점

- 시스템 구조 및 **운영 복잡성 증가**
- 서비스 간 통신, 데이터 일관성, 배포 자동화 등 추가적인 관리 필요
- 통합 테스트 및 모니터링이 상대적으로 어렵고, **초기 도입 진입장벽이** 높음


## 멀티 모듈(Multi-Module)

- 하나의 루트 Gradle(Maven) 프로젝트 안에 여러 개의 서브 모듈을 만들고, 각 모듈이 명확한 책임을 갖도록 분리하는 방식
- 멀티 모듈은 MSA의 내부 구조 정리, 또는 대규모 서비스 내 책임 분리를 위해 굉장히 효과적

### 예시 구조
```
my-app/
├── api/                 <- Web 진입점 (Controller)
├── domain-user/         <- 사용자 도메인
├── domain-order/        <- 주문 도메인
├── common/              <- 공통 라이브러리 (Exception, Config 등)
└── external-api/        <- 외부 API 호출 모듈 (ex. PG사 연동)

```

### 도입 기준
| 도입해도 되는 경우            | 도입 안 해도 되는 경우       |
| --------------------- | ------------------- |
| 팀원이 2명 이상, 병렬 개발 필요   | 개인/소규모 프로젝트         |
| 공통 모듈/도메인 경계 명확       | 기능이 단순하고 모놀리식이 더 나음 |
| 배치, 외부 API 등 별도 기능 많음 | 단일 웹 앱 구성만 있는 경우    |

## MSA에서의 통신 문제

1. 서버가 계속 뜨고 꺼지면 IP/Port가 바뀜
2. 동일한 서비스를 여러 개 띄우면 어떤 인스턴스로 요청을 보내야 할지 알 수 없음
3. 클라우드 환경에서는 인프라 자원이 동적으로 변함 → 고정 주소 불가능
→ 이를 해결하기 위한 핵심 도구 중 하나가 **Service Discovery**

# Service Discovery

- 서비스의 위치(IP, Port 등)를 중앙 레지스트리에 등록하고, 클라이언트가 이 레지스트리를 통해 위치를 조회하는 방식

## 주요 구성 요소
| 구성 요소                   | 설명                                     |
| ----------------------- | -------------------------------------- |
| Service Registry    | 모든 서비스의 위치(IP, Port 등)를 저장 (중앙 주소록 역할) |
| Service Registration | 각 서비스는 자신을 레지스트리에 등록                   |
| Service Lookup       | 클라이언트가 Registry에서 대상 서비스 위치를 조회        |

# Eureka 구현

## 1. Eureka Server 구현

### 1-1. build.gradle 설정


```groovy
ext {
    set('springCloudVersion', "2023.0.0")
}

dependencies {
    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}
```

### 1-2. application.yml 설정

```yaml
server:
  port: 8761

spring:
  application:
    name: discovery-server

eureka:
  client:
    register-with-eureka: false
    fetch-registry: false
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
  server:
    wait-time-in-ms-when-sync-empty: 5

management:
  endpoints:
    web:
      exposure:
        include: "*"

```

- port: Eureka 서버 포트 설정 (기본값: 8761)
- register-with-eureka: 자기 자신은 등록하지 않음
- fetch-registry: 다른 서비스의 레지스트리도 불필요
- defaultZone: 서비스가 등록될 기본 URL
- wait-time-in-ms-when-sync-empty: 서비스 등록 대기 시간 (기본 5분 → 5ms로 단축)
- actuator의 모든 endpoint 사용 가능

### 1-3. 메인 클래스에 서버 활성화

```java
@SpringBootApplication
@EnableEurekaServer
public class DiscoveryServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(DiscoveryServerApplication.class, args);
    }
}

```

- @EnableEurekaServer로 Eureka 서버 활성화


## 2. Eureka Client 구현

### 2-1. build.gradle 설정

```groovy
ext {
    set('springCloudVersion', "2023.0.0")
}

dependencies {
    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    ...
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}

```
### 2-2. application.yml 설정

```yaml
server:
  port: 8011

spring:
  application:
    name: member-service

eureka:
  instance:
    prefer-ip-address: true
  client:
    register-with-eureka: true
    fetch-registry: true
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/

management:
  endpoints:
    web:
      exposure:
        include: "*"


```

- application.name : Eureka에 등록될 고유 서비스 ID
- prefer-ip-address : IP 기반 등록 설정 (컨테이너 환경에서는 필수)
- register-with-eureka : Eureka에 등록 허용
- fetch-registry : 다른 서비스 정보 로컬에 캐시
- actuator를 통해 상태 점검 가능

### 2-3. 메인 클래스에 Client 활성화

```
@EnableDiscoveryClient
@SpringBootApplication
public class MemberServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(MemberServiceApplication.class, args);
    }
}

```
- @EnableDiscoveryClient로 Eureka Client 활성화

## 3. Eureka 대시보드 확인

| Application    | AMIs | VIP Address    | Status |
| -------------- | ---- | -------------- | ------ |
| MEMBER-SERVICE | 1    | member-service | UP     |
| BOARD-SERVICE  | 1    | board-service  | UP     |


## Eureka의 이점

http://localhost:8761
서비스를 모두 실행하면 대시보드에서 아래와 같이 확인 가능:

| 이점              | 설명                       |
| --------------- | ------------------------ |
| IP/Port 자동 관리   | 수동으로 주소 설정할 필요 없음        |
| 로드밸런싱 기반        | 인스턴스 여러 개 있을 경우 라운드로빈 가능 |
| 자동 장애 회복        | 비정상 인스턴스는 레지스트리에서 자동 제거  |
| Auto Scaling 대응 | 인스턴스가 늘어나도 자동 등록         |


#### 참고자료
- https://www.atlassian.com/ko/microservices/microservices-architecture/microservices-vs-monolith

- https://ksh-coding.tistory.com/137