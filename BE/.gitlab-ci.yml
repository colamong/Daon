# /.gitlab-ci.yml — deploy 전용: 이미지 빌드→푸시→EC2 배포

workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "deploy"'
    - when: never

default:
  tags: ["daon"]

stages: [build, deploy]

# 1) Docker Hub 빌드/푸시
build-and-push:
  stage: build
  rules: [ { if: '$CI_COMMIT_BRANCH == "deploy"' } ]
  script:
    - echo "=== Docker Hub Login ==="
    - docker login -u "$DOCKERHUB_USERNAME" -p "$DOCKERHUB_TOKEN"
    - echo "=== Docker Build ==="
    - docker build -t "$IMAGE_NAME:latest" "$BACKEND_DIR"
    - echo "=== Docker Push ==="
    - docker push "$IMAGE_NAME:latest"

# 2) EC2에서 컨테이너 교체 (heredoc으로 스크립트 생성 후 실행)
deploy-backend:
  stage: deploy
  needs: ["build-and-push"]
  rules: [ { if: '$CI_COMMIT_BRANCH == "deploy"' } ]
  script:
    - set -euxo pipefail
    - whoami && hostname
    - docker version && docker ps

    # 변수/경로 점검
    - echo "IMAGE_NAME=$IMAGE_NAME"
    - echo "CONTAINER_NAME=$CONTAINER_NAME"
    - echo "HOST_PORT=$HOST_PORT CONTAINER_PORT=$CONTAINER_PORT"
    - echo "ENV_FILE=$ENV_FILE"
    - test -f "$ENV_FILE" && echo "ENV_FILE exists" || (echo "ENV_FILE NOT FOUND"; exit 1)

    # 기존 컨테이너 정리 + 최신 이미지 받기
    - docker stop "$CONTAINER_NAME" || true
    - docker rm "$CONTAINER_NAME" || true
    - docker pull "$IMAGE_NAME:latest"

    # ==== 핵심: 런타임에 셸 스크립트를 만들고 실행 ====
    - cat > /tmp/deploy.sh <<'EOF'
      #!/usr/bin/env bash
      set -euxo pipefail
      docker run -d --name "${CONTAINER_NAME}" \
      --env-file "${ENV_FILE}" \
      -p "${HOST_PORT}:${CONTAINER_PORT}" \
      "${IMAGE_NAME}:latest"
      EOF
    - chmod +x /tmp/deploy.sh
    - echo "----- /tmp/deploy.sh (what will actually run) -----"
    - sed -n '1,120p' /tmp/deploy.sh
    - bash /tmp/deploy.sh

    - echo "=== Deployment Finished ==="
